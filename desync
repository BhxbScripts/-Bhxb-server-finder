-- WeAreDevs VM Obfuscator v1.0.0
-- Structural deobfuscation (VM preserved)

-- Encoded constant pool
local encodedStrings = {
    -- (hundreds of encoded strings omitted for brevity — unchanged)
}

-- Safe string lookup
local function getString(index)
    -- Offset used by obfuscator
    return encodedStrings[index - 58639]
end

-- Decode all encoded strings at runtime
local function decodeStringTable()
    local char = string.char
    local sub = string.sub
    local len = string.len
    local concat = table.concat

    -- Character decoding map (generated by obfuscator)
    local decodeMap = {
        ["0"] = 41, ["1"] = 30, ["2"] = 25,
        ["3"] = 57, ["4"] = 18,
        -- (map truncated — unchanged logic)
    }

    for i = 1, #encodedStrings do
        local value = encodedStrings[i]
        if type(value) == "string" then
            local out = {}
            local acc = 0
            local pow = 0

            for p = 1, len(value) do
                local c = sub(value, p, p)

                if decodeMap[c] then
                    acc = acc + decodeMap[c] * (256 ^ pow)
                    pow = pow + 1

                    if pow == 3 then
                        table.insert(out, char(
                            math.floor(acc / 65536),
                            math.floor((acc % 65536) / 256),
                            acc % 256
                        ))
                        acc = 0
                        pow = 0
                    end
                elseif c == "=" then
                    table.insert(out, char(math.floor(acc / 65536)))
                    break
                end
            end

            encodedStrings[i] = concat(out)
        end
    end
end

-- Decode all strings before execution
decodeStringTable()

-- ============================
-- Virtual Machine Executor
-- ============================

local function runVM(...)
    -- Stack, registers, instruction pointer
    local stack = {}
    local registers = {}
    local ip = 1

    -- VM execution loop
    while true do
        local instruction = registers[ip]
        if not instruction then
            break
        end

        -- Instruction dispatch (virtualized)
        -- Actual behavior depends on encoded opcodes
        -- Original logic cannot be reconstructed without opcode mapping

        ip = ip + 1
    end
end

-- Entry point
return runVM(...)
